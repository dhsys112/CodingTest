#

'''
BFS 알고리즘의 목적 
= 한 정점에서 시작해서, 모든 정점을 방문 

보통, DFS, BFS 둘다를 통해
한정점에서, 모든 정점을 방문하는 시도를 할 수 있다.

하지만
"최단거리" 의 경우는,
"BFS"만이 가능하다 

그리고 "모든 가중치가 1"이면
"최단 거리" 알고리즘이 된다 

"구현"과정에서 가장 중요한 것은
큐에 넣을 때, 
"방문" 처리를 해주는 것이다 

1) 간선의 가중치 '1'
2) '최소' 거리 표현
3) 그래프 표현

next[x] 
=> 주사위를 통해, 도착한 칸이 'X' 일때 
이동해야 하는 칸 

1) 일반칸    ?
2) 사다리칸  y ( x -> y 로 간다고 했을 때, y를 넣어주기 : 더 큰번호로 )
3) 뱀칸      y : 더 작은 번호로 

여기서 주로 고려해야 할 사항은 크게 2가지이다

1) 특정 칸에 대해서, 
방문 표시를 하면 안된다는 점 
2) x -> y -> next[y] ( next[y]는, y 정점에 갈때, 최종 도착 칸)
의 경로를 따를 때, 
y가 아닌, next[y]를 기준으로 판단해야 한다는 것
ex) 3 -> 5 -> 48
즉, 3에서 5로 갔는데, 사다리여서 48에 도착한다면 
48 이라는 칸이 '최종 도착 상태' 이기 때문에 
48 이라는 칸을, 기준으로 
생각해야 한다는 것이다 

즉, 우리는 x에서 바로 next[y]로 이동했다고 생각해야 한다는 것이다 

'''

from collections import deque

n,  m = map(int, input().split())
after = list(range(10))
dist = [-1] * 101
for _ in range(n + m):
    x, y = map(int, input().split())
    after[x] = y
'''
여기서, 사다리, 뱀에 대한 처리를
일반 칸에 대한 처리와 다르지 않게 
통일해준 것이라고 할 수 있다

즉, 
각종 예외 상황을 제거해버리기 위해서
사다리 , 뱀 에 대한 처리를
따로 생각하는 것이 아니라,

일반칸, 사다리, 뱀
을 한꺼번에 통일되게 생각한 것이다 
'''

dist[1] = 0  # dist[x] : x 칸까지의 최소 주사위 던진 횟수
q = deque()
q.append(1)

while q:
    x = q.popleft()
    for i in range(1, 6 + 1):
        y = x + i
        if y > 100:
            continue
        y = after[y]  # y가 아니라, 바로 after[y]로의 이동 진행
        if dist[y] == -1:  # 해당 y 좌표를 방문한 적이 없다면
            dist[y] = dist[x] + 1
            q.append(y)
print(dist[100])
